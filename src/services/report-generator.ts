// Audit Report Generator

import fs from 'fs/promises';
import path from 'path';
import type { AuditResult } from '../types/audit-types.js';

export class AuditReportGenerator {
  async generateMarkdownReport(result: AuditResult, outputPath?: string): Promise<string> {
    const content = this.buildMarkdownContent(result);

    const finalPath = outputPath || `audit-report-${result.brandName.toLowerCase().replace(/\s+/g, '-')}-${Date.now()}.md`;

    await fs.writeFile(finalPath, content, 'utf-8');

    return finalPath;
  }

  private buildMarkdownContent(result: AuditResult): string {
    let md = `# Brand Quality Audit Report: ${result.brandName}\n\n`;
    md += `**Generated**: ${new Date(result.auditDate).toLocaleString()}\n`;
    md += `**Audit Type**: Comprehensive\n\n`;
    md += `---\n\n`;

    // Overall Score
    md += `## ğŸ“Š Overall Quality Score: ${result.overallScore}/10\n\n`;
    md += this.getScoreEmoji(result.overallScore) + ' ' + this.getScoreLabel(result.overallScore) + '\n\n';

    // Dimension Scores
    md += `### Dimension Scores:\n\n`;
    md += `| Dimension | Score | Weight | Status | Details |\n`;
    md += `|-----------|-------|--------|--------|----------|\n`;

    Object.entries(result.scoreBreakdown).forEach(([name, dim]) => {
      md += `| ${this.formatDimensionName(name)} | ${dim.score}/10 | ${dim.weight * 100}% | ${this.getStatusEmoji(dim.status)} ${dim.status} | ${dim.details} |\n`;
    });
    md += `\n`;

    // Findings
    md += `## ğŸ” Key Findings\n\n`;

    const critical = result.findings.filter(f => f.severity === 'critical');
    const warnings = result.findings.filter(f => f.severity === 'warning');
    const info = result.findings.filter(f => f.severity === 'info');
    const success = result.findings.filter(f => f.severity === 'success');

    if (critical.length > 0) {
      md += `### âš ï¸ Critical Issues (Must Fix):\n\n`;
      critical.forEach((f, i) => {
        md += `${i + 1}. **${f.message}**\n`;
        if (f.details) md += `   - ${f.details}\n`;
        if (f.location) md += `   - Location: \`${f.location}\`\n`;
        md += `\n`;
      });
    }

    if (warnings.length > 0) {
      md += `### ğŸŸ¡ Warnings (Should Address):\n\n`;
      warnings.forEach((f, i) => {
        md += `${i + 1}. **${f.message}**\n`;
        if (f.details) md += `   - ${f.details}\n`;
        md += `\n`;
      });
    }

    if (success.length > 0) {
      md += `### âœ… Strengths:\n\n`;
      success.forEach((f, i) => {
        md += `${i + 1}. ${f.message}\n`;
      });
      md += `\n`;
    }

    // Recommendations
    md += `## ğŸš€ Recommended Actions\n\n`;

    const highPriority = result.recommendations.filter(r => r.priority === 'high');
    const mediumPriority = result.recommendations.filter(r => r.priority === 'medium');
    const lowPriority = result.recommendations.filter(r => r.priority === 'low');

    if (highPriority.length > 0) {
      md += `### High Priority:\n\n`;
      highPriority.forEach((r, i) => {
        md += `${i + 1}. **${r.action}** (${r.estimatedEffort})\n`;
        md += `   - Impact: ${r.impact}\n\n`;
      });
    }

    if (mediumPriority.length > 0) {
      md += `### Medium Priority:\n\n`;
      mediumPriority.forEach((r, i) => {
        md += `${i + 1}. **${r.action}** (${r.estimatedEffort})\n`;
        md += `   - Impact: ${r.impact}\n\n`;
      });
    }

    if (lowPriority.length > 0) {
      md += `### Low Priority:\n\n`;
      lowPriority.forEach((r, i) => {
        md += `${i + 1}. ${r.action} (${r.estimatedEffort})\n\n`;
      });
    }

    // Improvement Plan
    md += `## ğŸ“ˆ Quality Improvement Plan\n\n`;
    md += `**Current State**: ${result.qualityImprovement.currentScore}/10\n`;
    md += `**Target State**: ${result.qualityImprovement.targetScore}/10\n\n`;
    md += `**Steps**:\n\n`;

    result.qualityImprovement.steps.forEach((step) => {
      md += `${step.step}. ${step.action}\n`;
      md += `   - Expected improvement: +${step.expectedImprovement}\n`;
      md += `   - Estimated time: ${step.estimatedTime}\n\n`;
    });

    md += `**Estimated Total Effort**: ${result.qualityImprovement.totalEffort}\n`;
    md += `**Required Expertise**: ${result.qualityImprovement.requiredExpertise}\n\n`;

    // Footer
    md += `---\n\n`;
    md += `**Next Steps**:\n`;
    md += `1. Review this report with your team\n`;
    md += `2. Prioritize critical issues\n`;
    md += `3. Implement recommendations\n`;
    md += `4. Re-run audit after fixes\n\n`;
    md += `*Generated by Brand Quality Auditor v1.0.0*\n`;

    return md;
  }

  private formatDimensionName(name: string): string {
    return name
      .replace(/([A-Z])/g, ' $1')
      .replace(/^./, (str) => str.toUpperCase())
      .trim();
  }

  private getScoreLabel(score: number): string {
    if (score >= 9) return 'Exceptional - Consulting-grade quality';
    if (score >= 8) return 'Excellent - Ready for presentation';
    if (score >= 7) return 'Good - Minor improvements needed';
    if (score >= 6) return 'Adequate - Needs work';
    if (score >= 5) return 'Below Standard - Significant work needed';
    return 'Poor - Major revision required';
  }

  private getScoreEmoji(score: number): string {
    if (score >= 9) return 'ğŸŒŸ';
    if (score >= 8) return 'âœ…';
    if (score >= 7) return 'ğŸ‘';
    if (score >= 6) return 'ğŸŸ¡';
    if (score >= 5) return 'âš ï¸';
    return 'âŒ';
  }

  private getStatusEmoji(status: string): string {
    switch (status) {
      case 'excellent': return 'âœ…';
      case 'good': return 'ğŸ‘';
      case 'needs-work': return 'ğŸŸ¡';
      case 'critical': return 'âŒ';
      default: return 'â€¢';
    }
  }
}
